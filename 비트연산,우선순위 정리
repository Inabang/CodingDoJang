&	비트 AND
|	비트 OR
^	비트 XOR (배타적 OR, Exclusive OR)
~	비트 NOT
<<	비트를 왼쪽으로 시프트
>>	비트를 오른쪽으로 시프트
&=	비트 AND 연산 후 할당
|=	비트 OR 연산 후 할당
^=	비트 XOR 연산 후 할당
<<=	비트를 왼쪽으로 시프트한 후 할당
>>=	비트를 오른쪽으로 시프트한 후 할당


부호있는 자료형의 비트연산 (signed)

부호있는 자료형의 비트를 오른쪽으로 이동하면 
모자라는 공간은 부호 비트의 값으로 채워진다 
그리고 비트를 왼쪽으로 이동시키면 부호 비트를 덮어쓰므로 부호가 바뀔수도있다.

1000 0000 (-128)
            >> 2
1110 0000 (-32)

0010 0000 (32)
           <<2
1000 0000 (-128)


비트연산자로 Flag 처리하기

flag |= mask 플래그의 특정 비트를 킨다
flag &= ~mask 플래그의 특정 비트를 끈다
flag ^= mask 플래그의 특정 비트를 토글한다
flag & mask 플래그의 특정 비트가 켜져있는지 검사한다.


우선순위

후위연산 -> 함수호출 -> 복합리터럴 -> 전위연산 -> NOT -> 포인터 역참조 -> &(주소) -> sizeof
-> 사칙연산(*/%+) -> 시프트 -> 비교연산 -> 비트비교 연산 -> 삼항 -> 할당


비트 XOR 연산자는 간단한 암호화에 사용한다

int plane = 100; => 평문
int key = 57; => 암호키

int encrypted = plane ^ key => 암호화
--> 93

int decrypted = encrypted ^ key => 복호화
--> 100

즉 XOR은 다음과 같은특성을가진다

a ^ b = c
c ^ b = a
c ^ a = b

XOR의 특성을 활용하면 임시 변수를 사용하지 않고 두 변수의 값을 바꿀 수도 있다.

int a = 10;
int b = 20;

a = a ^ b; 
b = a ^ b;
a = a ^ b;

(a와 b의 값이 서로바뀐다)



나누기 2를 하는 좋은방법

숫자를 비트로 다룰때는 비트를사용하고 그냥 숫자를 다룰땐 나누기 연산자를 사용해야한다.